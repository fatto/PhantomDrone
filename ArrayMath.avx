#include "ArrayMath.hpp"

template <typename T>
vec4_simd<T>::vec4_simd() :
	data(_mm256_setzero_pd()) {}
template <typename T>
vec4_simd<T>::vec4_simd(typename simd<T>::type v) :
	data(v) {}
template <typename T>
vec4_simd<T>::vec4_simd(T _s) :
	data(_mm256_set1_pd(_s)) {}
template <typename T>
vec4_simd<T>::vec4_simd(T _a, T _b, T _c,T _d) :
	data(_mm256_setr_pd(_a, _b, _c, _d)) {}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator=(vec4_simd<T> const& v)
{
	data = v.data;
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator+=(T _s)
{
	data = _mm256_add_pd(data, _mm256_set1_pd(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator+=(vec4_simd<T> const& v)
{
	data = _mm256_add_pd(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator-=(T _s)
{
	data = _mm256_sub_pd(data, _mm256_set1_pd(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator-=(vec4_simd<T> const& v)
{
	data = _mm256_sub_pd(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator*=(T _s)
{
	data = _mm256_mul_pd(data, _mm256_set1_pd(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator*=(vec4_simd<T> const& v)
{
	data = _mm256_mul_pd(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator/=(T _s)
{
	data = _mm256_div_pd(data, _mm256_set1_pd(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator/=(vec4_simd<T> const& v)
{
	data = _mm256_div_pd(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::normalize()
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(*this);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);
	// sqrt(x^2 + y^2 + z^2 + w^2)
	res = sqrt(res);
	// (x, y, z, w)/sqrt(x^2 + y^2 + z^2 + w^2)
	/*data = data/res;*/
	*this /= res;

	return *this;
}


template <typename T>
vec4_simd<T> operator+(vec4_simd<T> const& v, T _s)
{
	return _mm256_add_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator+(T _s, vec4_simd<T> const& v)
{
	return _mm256_add_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator+(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_add_pd(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator-(vec4_simd<T> const& v, T _s)
{
	return _mm256_sub_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator-(T _s, vec4_simd<T> const& v)
{
	return _mm256_sub_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator-(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_sub_pd(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator*(vec4_simd<T> const& v, T _s)
{
	return _mm256_mul_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator*(T _s, vec4_simd<T> const& v)
{
	return _mm256_mul_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator*(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_mul_pd(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator/(vec4_simd<T> const& v, T _s)
{
	return _mm256_div_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator/(T _s, vec4_simd<T> const& v)
{
	return _mm256_div_pd(v.data, _mm256_set1_pd(_s));
}
template <typename T>
vec4_simd<T> operator/(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_div_pd(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator-(vec4_simd<T> const& v)
{
	union
	{
		uint64_t i;
		T d;
	} u;
	u.i = 0x8000000000000000; // sign_mask
	return _mm256_and_pd(_mm256_set1_pd(u.d), v.data);
}


template <typename T>
vec4_simd<T> operator<(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(_mm256_cmp_pd(v1.data, v2.data, _CMP_LT_OS),_mm256_set1_pd(1.0));
}
template <typename T>
vec4_simd<T> operator<=(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(_mm256_cmp_pd(v1.data, v2.data, _CMP_LE_OS),_mm256_set1_pd(1.0));
}
template <typename T>
vec4_simd<T> operator>(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(_mm256_cmp_pd(v1.data, v2.data, _CMP_NLE_US),_mm256_set1_pd(1.0));
}
template <typename T>
vec4_simd<T> operator>=(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(_mm256_cmp_pd(v1.data, v2.data, _CMP_NLT_US),_mm256_set1_pd(1.0));
}
template <typename T>
vec4_simd<T> operator==(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(_mm256_cmp_pd(v1.data, v2.data, _CMP_EQ_OQ),_mm256_set1_pd(1.0));
}
template <typename T>
vec4_simd<T> operator!=(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(_mm256_cmp_pd(v1.data, v2.data, _CMP_NEQ_UQ),_mm256_set1_pd(1.0));
}

template <typename T>
vec4_simd<T> operator&(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_and_pd(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> operator|(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_or_pd(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> operator^(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_xor_pd(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> lt(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_cmp_pd(v1.data, v2.data, _CMP_LT_OS);
}
template <typename T>
vec4_simd<T> le(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_cmp_pd(v1.data, v2.data, _CMP_LE_OS);
}
template <typename T>
vec4_simd<T> gt(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_cmp_pd(v1.data, v2.data, _CMP_NLE_US);
}
template <typename T>
vec4_simd<T> ge(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_cmp_pd(v1.data, v2.data, _CMP_NLT_US);
}
template <typename T>
vec4_simd<T> eq(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_cmp_pd(v1.data, v2.data, _CMP_EQ_OQ);
}
template <typename T>
vec4_simd<T> neq(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_cmp_pd(v1.data, v2.data, _CMP_NEQ_UQ);
}
template <typename T>


vec4_simd<T> abs(vec4_simd<T> const& v)
{
	union
	{
		uint64_t i;
		T d;
	} u;
	u.i = 0x7fffffffffffffff; // abs_mask  -- 0x8000000000000000 sign_mask
	return _mm256_and_pd(_mm256_set1_pd(u.d), v.data);
}
template <typename T>
vec4_simd<T> square(vec4_simd<T> const& v)
{
	return _mm256_mul_pd(v.data, v.data);
}
template <typename T>
vec4_simd<T> sqrt(vec4_simd<T> const& v)
{
	return _mm256_sqrt_pd(v.data);
}
template <typename T>
vec4_simd<T> normalize(vec4_simd<T> const& v)
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(v);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);
	// sqrt(x^2 + y^2 + z^2 + w^2)
	res = sqrt(res);
	// (x, y, z, w)/sqrt(x^2 + y^2 + z^2 + w^2)
	return v/res;
}
template <typename T>
vec4_simd<T> length(vec4_simd<T> const& v)
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(v);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);
	// sqrt(x^2 + y^2 + z^2 + w^2)
	res = sqrt(res);

	return res;
}
template <typename T>
vec4_simd<T> lengthsquare(vec4_simd<T> const& v)
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(v);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);

	return res;
}
template <typename T>
vec4_simd<T> dot(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	vec4_simd<T> res = v1*v2;
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);
	return res;
}
template <typename T>
vec4_simd<T> max_(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_max_pd(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> min_(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_min_pd(v1.data, v2.data);
}
template <typename T>
bool any(vec4_simd<T> const& v)
{
	return _mm256_movemask_pd(v.data) != 0;
}
template <typename T>
bool all(vec4_simd<T> const& v)
{
return _mm256_movemask_pd(v.data) == 0x000f;
}