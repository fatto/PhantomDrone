#include "ArrayMath.hpp"

template <typename T>
vec4_simd<T>::vec4_simd() :
	data(_mm_setzero_ps()) {}
template <typename T>
vec4_simd<T>::vec4_simd(typename simd<T>::type v) :
	data(v) {}
template <typename T>
vec4_simd<T>::vec4_simd(T _s) :
	data(_mm_set_ps1(_s)) {}
template <typename T>
vec4_simd<T>::vec4_simd(T _a, T _b, T _c,T _d) :
	data(_mm_setr_ps(_a, _b, _c, _d)) {}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator=(vec4_simd<T> const& v)
{
	data = v.data;
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator+=(T _s)
{
	data = _mm_add_ps(data, _mm_set_ps1(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator+=(vec4_simd<T> const& v)
{
	data = _mm_add_ps(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator-=(T _s)
{
	data = _mm_sub_ps(data, _mm_set1_ps1(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator-=(vec4_simd<T> const& v)
{
	data = _mm_sub_ps(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator*=(T _s)
{
	data = _mm_mul_(data, _mm_set_ps1(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator*=(vec4_simd<T> const& v)
{
	data = _mm_mul_ps(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::operator/=(T _s)
{
	data = _mm_div_ps(data, _mm_set_ps1(_s));
	return *this;
}
template <typename T>
vec4_simd<T>& vec4_simd<T>::operator/=(vec4_simd<T> const& v)
{
	data = _mm_div_ps(data, v.data);
	return *this;
}

template <typename T>
vec4_simd<T>& vec4_simd<T>::normalize()
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(*this);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);
	// sqrt(x^2 + y^2 + z^2 + w^2)
	res = sqrt(res);
	// (x, y, z, w)/sqrt(x^2 + y^2 + z^2 + w^2)
	/*data = data/res;*/
	*this /= res;

	return *this;
}


template <typename T>
vec4_simd<T> operator+(vec4_simd<T> const& v, T _s)
{
	return _mm_add_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator+(T _s, vec4_simd<T> const& v)
{
	return _mm_add_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator+(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_add_ps(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator-(vec4_simd<T> const& v, T _s)
{
	return _mm_sub_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator-(T _s, vec4_simd<T> const& v)
{
	return _mm_sub_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator-(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_sub_ps(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator*(vec4_simd<T> const& v, T _s)
{
	return _mm_mul_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator*(T _s, vec4_simd<T> const& v)
{
	return _mm_mul_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator*(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_mul_ps(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator/(vec4_simd<T> const& v, T _s)
{
	return _mm_div_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator/(T _s, vec4_simd<T> const& v)
{
	return _mm_div_ps(v.data, _mm_set_ps1(_s));
}
template <typename T>
vec4_simd<T> operator/(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_div_ps(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> operator-(vec4_simd<T> const& v)
{
	union
	{
		uint32_t i;
		T d;
	} u;
	u.i = 0x80000000; // sign_mask
	return _mm_and_ps(_mm_set_ps1(u.d), v.data);
}


template <typename T>
vec4_simd<T> operator<(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_ps(_mm_cmplt_ps(v1.data, v2.data),_mm_set_ps1(1.f));
}
template <typename T>
vec4_simd<T> operator<=(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_pd(_mm_cmple_ps(v1.data, v2.data),_mm_set_ps1(1.f));
}
template <typename T>
vec4_simd<T> operator>(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_pd(_mm_cmpgt_ps(v1.data, v2.data),_mm_set_ps1(1.f));
}
template <typename T>
vec4_simd<T> operator>=(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_pd(_mm_cmpge_ps(v1.data, v2.data),_mm_set_ps1(1.f));
}
template <typename T>
vec4_simd<T> operator==(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_pd(_mm_cmpeq_ps(v1.data, v2.data),_mm_set_ps1(1.f));
}
template <typename T>
vec4_simd<T> operator!=(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_pd(_mm_cmpneq_ps(v1.data, v2.data),_mm_set_ps1(1.0));
}

template <typename T>
vec4_simd<T> operator&(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_and_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> operator|(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_or_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> operator^(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_xor_ps(v1.data, v2.data);
}

template <typename T>
vec4_simd<T> lt(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_cmplt_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> le(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_cmple_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> gt(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_cmpgt_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> ge(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_cmpge_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> eq(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_cmpeq_ps(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> neq(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm_cmpne_ps(v1.data, v2.data);
}
template <typename T>


vec4_simd<T> abs(vec4_simd<T> const& v)
{
	union
	{
		uint64_t i;
		T d;
	} u;
	u.i = 0x7fffffff; // abs_mask  -- 0x8000000000000000 sign_mask
	return _mm_and_ps(_mm_set_ps1(u.d), v.data);
}
template <typename T>
vec4_simd<T> square(vec4_simd<T> const& v)
{
	return _mm_mul_ps(v.data, v.data);
}
template <typename T>
vec4_simd<T> sqrt(vec4_simd<T> const& v)
{
	return _mm_sqrt_ps(v.data);
}
template <typename T>
vec4_simd<T> normalize(vec4_simd<T> const& v)
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(v);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm_hadd_ps(res.data,res.data);
	res.data = _mm_hadd_ps(res.data, res.data);
	// 1/sqrt(x^2 + y^2 + z^2 + w^2)
	res = _mm_rsqrt_ps(res);
	return v * res;
}
template <typename T>
vec4_simd<T> length(vec4_simd<T> const& v)
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(v);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);
	// sqrt(x^2 + y^2 + z^2 + w^2)
	res = sqrt(res);

	return res;
}
template <typename T>
vec4_simd<T> lengthsquare(vec4_simd<T> const& v)
{
	// x^2, y^2, z^2, w^2
	vec4_simd<T> res = square(v);
	// x^2 + y^2 + z^2 + w^2
	res.data = _mm256_hadd_pd(res.data, _mm256_permute2f128_pd(res.data, res.data, 1));
	res.data = _mm256_hadd_pd(res.data, res.data);

	return res;
}
template <typename T>
vec4_simd<T> dot(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	vec4_simd<T> res = v1*v2;
	// r1, r2, r3, r4
	// r1+r2, r3+r4,
	res.data = _mm_hadd_ps(res.data, res.data);
	res.data = _mm_hadd_ps(res.data, res.data);
	return res;
}
template <typename T>
vec4_simd<T> max_(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_max_pd(v1.data, v2.data);
}
template <typename T>
vec4_simd<T> min_(vec4_simd<T> const& v1, vec4_simd<T> const& v2)
{
	return _mm256_min_pd(v1.data, v2.data);
}
template <typename T>
bool any(vec4_simd<T> const& v)
{
	return _mm_movemask_ps(v.data) != 0;
}
template <typename T>
bool all(vec4_simd<T> const& v)
{
	return _mm_movemask_ps(v.data) == 0x000F;
}